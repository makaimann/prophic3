/** -*- C++ -*-
 * 
 * LTL verification
 * author: Alberto Griggio <griggio@fbk.eu>
 *         Jakub Daniel <jakub@fbk.eu>
 * 
 * This file is part of ic3ia.
 * Copyright (C) 2015-2016 Fondazione Bruno Kessler.
 *
 * ic3ia is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * ic3ia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ic3ia.  If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include "ts.h"
#include "unroll.h"
#include "ia.h"
#include "utils.h"
#include "opts.h"
#include "bmc.h"


namespace ic3ia {

/**
 * Helper class for defining a ranking relation (i.e. a well-founded relation
 * that is part of a disjunctive transition invariant)
 */
struct RankRel {
    msat_term rank; ///< the ranking function
    msat_term bound; ///< the lower bound

    RankRel()
    {
        MSAT_MAKE_ERROR_TERM(rank);
        MSAT_MAKE_ERROR_TERM(bound);
    }

    RankRel(msat_term r, msat_term b):
        rank(r), bound(b) {}

    bool ok() const
    { return !MSAT_ERROR_TERM(rank) && !MSAT_ERROR_TERM(bound); }

    bool operator==(const RankRel &other) const
    {
        return ok() && other.ok() && rank == other.rank && bound == other.bound;
    }

    bool operator!=(const RankRel &other) const { return !(*this == other); }
};

typedef std::vector<RankRel> RankRelList;
typedef std::pair<msat_term, msat_term> TermPair;
typedef std::vector<TermPair> TermPairList;


/**
 * Encoding of a liveness property F(G(p)) as a safety property, using a
 * combination of abstract L2S, k-liveness and disjunctive well-founded
 * transition invariants
 */
class LiveEncoder {
public:
    LiveEncoder(TransitionSystem &ts, const Options &opts);
    
    void encode(const TermSet &preds, const RankRelList &ranks);
    ///< encode the property using the given preds for abstract L2S and the
    ///< given ranks for the transition invariant

    msat_term init_constraint() const { return init_; }
    ///< additional init constraints generated by the last encode() call
    
    msat_term trans_constraint() const { return trans_; }
    ///< additional trans constraints generated by the last encode() call
    
    const TermSet &init_predicates() const { return initpreds_; }
    ///< additional predicates for implicit abstraction generated by the last
    ///< encode() call

    msat_term ranked() const { return ranked_; }
    ///< ranked signal of the encoding (used by LiveRefiner)
    
    msat_term saved() const { return saved_; }
    ///< saved signal of the encoding (used by LiveRefiner)
    
    msat_term prop() const { return prop_; }
    ///< the safety property generated by the last encode() call
    
    void set_klive_counter(size_t k);
    ///< if k-liveness is enabled, increment the k-live counter for the next
    ///< encode() call

    const TermList &new_statevars() const { return newstatevars_; }
    ///< new state variables generated by the last encode() call
    
private:
    void encode_l2s(const TermSet &preds, msat_term fairness);
    ///< perform the abstract L2S encoding for the given fairness constraint,
    ///< using the given set of predicates
    
    void encode_kliveness();
    ///< perform the k-liveness encoding
    
    TransitionSystem &ts_; ///< the input transition system
    const Options &opts_; ///< the input options
    
    VarProvider vp_; ///< provider of fresh variables for encode()
    TermList statevars_; ///< list of original state variables
    TermList newstatevars_; ///< new state variables
    
    bool firstcall_;
    
    TermMap var2orig_; ///< mapping from state vars to their 0-copy
    TermMap var2hat_; ///< mapping from state vars to their hat-copy
    TermMap pred2p_; ///< mapping from L2S predicates to their labels 

    msat_term init_; ///< initial constraints generated by encode()
    msat_term trans_; ///< transition constraints generated by encode()
    msat_term prop_; ///< safety property generated by encode()
    
    msat_term ranked_; ///< ranked signal in the encoding
    msat_term saved_; ///< saved signal in the encoding
    msat_term delta_; ///< delta value for ensuring that at least one of the
                      ///< RankRelS decreases

    msat_term l2s_init_; ///< initial constraints generated by encode_l2s()
    msat_term l2s_trans_; ///< transition constraints generated by encode_l2s()
    msat_term l2s_bad_; ///< (negated) safety property generated by encode_l2s()
    msat_term l2s_triggered_; ///< triggered signal in the L2S encoding
    msat_term l2s_seen_; ///< seen signal in the L2S encoding

    msat_term klive_var_; ///< k-liveness counter variable
    msat_term klive_counter_; ///< k-liveness counter value
    
    msat_term klive_init_; ///< init constraints generated by encode_kliveness()
    msat_term klive_trans_; ///< trans constraints generated by
                            ///< encode_kliveness()

    TermSet initpreds_; ///< extra predicates for implicit abstraction
                        ///< generated by encode()
    TermList tmplist_; ///< temporary storage
};


/**
 * Synthesis of linear ranking functions for simple lasso programs, using the
 * technique described in:
 *
 *   Matthias Heizmann, Jochen Hoenicke, Jan Leike, Andreas Podelski:
 *   Linear Ranking for Linear Lasso Programs. ATVA 2013: 365-380
 */
class LassoRankFinder {
public:
    LassoRankFinder(const TransitionSystem &ts);
    
    RankRel operator()(msat_term stem, msat_term loop);
    ///< try to generate a ranking relation for the simple lasso program
    ///< consisting of the given stem and loop. An invalid relation is returned
    ///< in case of failure

private:
    /**
     * internal representation of a single linear inequality (lhs <= rhs)
     */
    struct Leq {
        TermMap lhs;
        msat_term rhs;
        bool strict;

        Leq(): strict(false)
        {
            MSAT_MAKE_ERROR_TERM(rhs);
        }

        explicit Leq(msat_term r): rhs(r), strict(false) {}
    };
    Leq mk_leq(msat_env env, msat_term term);
    ///< convert a term to a Leq
    
    void assert_farkas(msat_env env, const std::vector<Leq> &matrix,
                       const Leq &ineq, int idx);
    ///< assert the Farkas constraints for the given matrix and inequality
    ///< (see the above paper for details)
    
    void get_matrix(msat_term formula, std::vector<Leq> &out);
    ///< generate the matrix of inequalities corresponding to the given formula
    
    msat_term get_lambda(int i, int j);
    ///< generate a Farkas lambda coefficient with the given index
    
    msat_term get_epsilon(int i);
    ///< generate an epsilon term with the given index (for handling strict
    ///< inequalities)
    
    Leq get_ineq(TermList *cur, TermList *next, msat_term bound);
    ///< generate an inequality over state variables (current, next or both,
    ///< depending on whether the arguments are not NULL). The coefficients are
    ///< read from the input vectors
    
    Logger &logleq(int level, const Leq &l);
    ///< logging for inequalities

    const TransitionSystem &ts_; ///< the input transition system
    
    VarProvider vp_; ///< fresh variable provider
    TermList statevars_; ///< list of state variables
    
    TermList epsilon_; ///< cache for epsilon terms
    TermList s_; ///< list of "s" coefficents for the Farkas encoding (see
                 ///< paper)
    TermList r_; ///< list of "r" coefficents for the Farkas encoding
    msat_term s0_; ///< "s0" constant for the Farkas encoding
    msat_term r0_; ///< "r0" constant for the Farkas encoding
    msat_term delta_; ///< "delta" constant for the Farkas encoding
    
    msat_term lbl_r0_;
    ///< Boolean label for the constraint (r0 = 0). This is used to bias the 
    ///< search towards solutions with (r0 = 0), using the preferred vars
    ///< mechanism available in MathSAT
    
    msat_term lbl_s0_;
    ///< Boolean label for the constraint (s0 = 0). This is used to bias the 
    ///< search towards solutions with (s0 = 0), using the preferred vars
    ///< mechanism available in MathSAT

    struct pair_hash_eq {
        size_t operator()(const std::pair<int, int> &p) const {
            return (size_t(p.first) << (sizeof(size_t) * 4)) | size_t(p.second);
        }

        bool operator()(const std::pair<int, int> &a,
                        const std::pair<int, int> &b) const
        {
            return (a.first == b.first) && (a.second == b.second);
        }
    };
    typedef std::unordered_map<std::pair<int, int>, msat_term,
                               pair_hash_eq, pair_hash_eq> LambdaMap;
    LambdaMap lambdas_; ///< cache of lambda vars for the Farkas encoding
};


/**
 * Refinement for the extended liveness to safety encoding
 */
class LiveRefiner {
public:
    LiveRefiner(const TransitionSystem &ts, const Options &opts,
                Abstractor &abs, LiveEncoder &liveenc);

    msat_truth_value refine(const std::vector<TermList> &cex,
                            const TermSet &preds, const RankRelList &rankrels);
    ///< check whether the given counterexample trace is spurious, assuming
    ///< that the encoding into safety was done using the given predicates and
    ///< ranking relations

    const TermSet &used_predicates() { return refine_prefix_preds_; }
    ///< get the set of predicates used for blocking the abstract cex
    
    const RankRelList &used_rankrels() { return new_rankrels_; }
    ///< get the set of ranking relations used for blocking the abstract cex

    int counterexample(std::vector<TermList> &out);
    ///< generate a concrete cex trace from the abstract one (for which
    ///< refine() returned MSAT_FALSE)

private:
    msat_truth_value refine_prefix(const std::vector<TermList> &cex,
                                   const TermSet &preds, size_t loopidx);
    ///< try refining the encoding by showing unfeasibility of a finite
    ///< unrolling of the abstract trace
    
    RankRel refine_ranking(const std::vector<TermList> &cex,
                           const TermSet &preds,
                           const RankRelList &rankrels, size_t loopidx);
    ///< try refining the encoding by generating new linear ranking relations
    ///< using the Farkas' lemma
    
    RankRel refine_ranking_templates(msat_env wenv,
                                     const std::vector<TermList> &cex,
                                     size_t loopidx, const TermSet &preds,
                                     const RankRelList &rankrels);
    ///< try refining the encoding by generating new linear ranking relations
    ///< using a simple template-based heuristic
    
    void init_ranking_templates();
    ///< initialize the set of ranking templates from the constraints in
    ///< the transition system
    
    void build_lasso_cex(msat_env env, size_t loopidx, size_t lastidx);
    ///< generate a concrete lasso-shape counterexample trace
    
    void minimize_prefix_predicates(const std::vector<TermList> &cex,
                                    size_t loopidx, size_t lastidx,
                                    const TermSet &preds);
    ///< minimize (using unsat cores) the set of predicates sufficient to
    ///< block a finite unrolling of the abstract cex trace
    
    template <class S>
    Logger &logstate(int level, const S &state);
    ///< logging function
        
    const TransitionSystem &ts_; ///< the input transition system
    Abstractor &abs_; ///< the abstractor for implicit abstraction
    LiveEncoder &liveenc_; ///< the encoder for the liveness property
    
    TermList statevars_; ///< the list of original state variables
    TermHashSet boolstatevars_; ///< the set of boolean state variables
    
    int maxiter_; ///< maximum number of unrollings for prefix blocking
    bool eager_; ///< if true, use eager strategy
    bool use_templates_; ///< if true, use templates for ranking relations
    bool no_cex_; ///< if true, do not search for counterexamples
    
    Unroller un_; ///< unroller for prefix-based refinement
    LassoRankFinder rf_; ///< ranking relation finder
    bool use_ranking_; ///< if false, don't use ranking relations
    TermSet refine_prefix_preds_; ///< new predicates found by refining the
                                  ///< prefix
    RankRelList new_rankrels_; ///< new ranking relations found

    bool first_; ///< true at first call
    msat_term origtrans_; ///< the original transition relation
    TermList ranktemplates_; ///< available templates for ranking relations

    bool bmc_cex_; ///< if true, use BMC for finding counterexamples
    Bmc bmc_prover_; ///< BMC prover for finding counterexamples
    
    std::vector<TermList> lasso_cex_; ///< lasso-shaped counterexaple for
                                      ///< falsified properties
    int lasso_loop_; ///< index of the loop in the cex

    bool klive_progress_; ///< if true, enable k-liveness
    size_t klive_last_bound_; ///< value of the k-liveness counter

    bool minpreds_; ///< if true, use pred minimization in prefix refinement
    PredRefMinimizer predminimizer_; ///< minimizer for prefix refinement
};


} // namespace ic3ia
